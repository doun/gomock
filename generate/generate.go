// Copyright 2010 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package generate contains functions useful to the mockgen command. Most
// users should look at that command instead of this package.
package generate

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"reflect"
	"strconv"
	"strings"
)

const (
	gomockImportPath = "github.com/dsymonds/gomock/gomock"
)

type generator struct {
	w        io.Writer
	indent   string

	imports map[string]string // map from package name to import path
}

func (g *generator) p(format string, args ...interface{}) {
	fmt.Fprintf(g.w, g.indent+format+"\n", args...)
}

func (g *generator) in() {
	g.indent += "\t"
}

func (g *generator) out() {
	if len(g.indent) > 0 {
		g.indent = g.indent[0 : len(g.indent)-1]
	}
}

// TODO(jacobsa): Delete this if it remains unused.
func getPackagePath(t reflect.Type) string {
	// Work around this bug in Go:
	//     http://code.google.com/p/go/issues/detail?id=2660
	var someErrPtr *error
	if t == reflect.TypeOf(someErrPtr).Elem() {
		return ""
	}

	return t.PkgPath()
}

// typesUsedByInterface returns a list of all types used by an interface.
func typesUsedByInterface(it reflect.Type) []reflect.Type {
	l := make([]reflect.Type, 0)

	for i := 0; i < it.NumMethod(); i++ {
		methodType := it.Method(i).Type

		for j := 0; j < methodType.NumIn(); j++ {
			l = append(l, methodType.In(j))
		}

		for j := 0; j < methodType.NumOut(); j++ {
			l = append(l, methodType.Out(j))
		}
	}

	return l
}

// getPackageIdentifier returns the package identifier for the supplied type,
// or the empty string if there is none.
func getPackageIdentifier(t reflect.Type) string {
	components := strings.Split(t.String(), ".")
	switch len(components) {
	case 1: return ""
	case 2: return components[0]
	}

	panic("Unexpected type string: " + t.String())
}

func (g *generator) ScanImports(interfaces []reflect.Type) {
	for _, it := range interfaces {
		for _, t := range typesUsedByInterface(it) {
			g.imports[getPackageIdentifier(t)] = t.PkgPath()
		}
	}
}

func (g *generator) Generate(pkg string, types []reflect.Type) error {
	g.p("// Automatically generated by MockGen. DO NOT EDIT!")
	g.p("")

	if _, ok := g.imports["gomock"]; ok {
		log.Fatalf("interface uses gomock package, so is not mockable.")
	}
	g.imports["gomock"] = gomockImportPath

	g.p("package %v", pkg)
	g.p("")
	g.p("import (")
	g.in()
	for pkg, path := range g.imports {
		g.p("%v %q", pkg, path)
	}
	g.out()
	g.p(")")

	for _, it := range types {
		if err := g.GenerateMockInterface(it); err != nil {
			return err
		}
	}

	return nil
}

func (g *generator) GenerateMockInterface(it reflect.Type) error {
	typeName := it.Name()
	mockType := fmt.Sprintf("Mock%v", typeName)

	g.p("")
	g.p("// Mock of %v interface", typeName)
	g.p("type %v struct {", mockType)
	g.in()
	g.p("ctrl     *gomock.Controller")
	g.p("recorder *_%vRecorder", mockType)
	g.out()
	g.p("}")
	g.p("")

	g.p("// Recorder for %v (not exported)", mockType)
	g.p("type _%vRecorder struct {", mockType)
	g.in()
	g.p("mock *%v", mockType)
	g.out()
	g.p("}")
	g.p("")

	// TODO: Re-enable this if we can import the interface reliably.
	//g.p("// Verify that the mock satisfies the interface at compile time.")
	//g.p("var _ %v = (*%v)(nil)", typeName, mockType)
	//g.p("")

	g.p("func New%v(ctrl *gomock.Controller) *%v {", mockType, mockType)
	g.in()
	g.p("mock := &%v{ctrl: ctrl}", mockType)
	g.p("mock.recorder = &_%vRecorder{mock}", mockType)
	g.p("return mock")
	g.out()
	g.p("}")
	g.p("")

	// XXX: possible name collision here if someone has EXPECT in their interface.
	g.p("func (_m *%v) EXPECT() *_%vRecorder {", mockType, mockType)
	g.in()
	g.p("return _m.recorder")
	g.out()
	g.p("}")

	g.GenerateMockMethods(mockType, it)

	return nil
}

func (g *generator) GenerateMockMethods(mockType string, it reflect.Type) {
	for i := 0; i < it.NumMethod(); i++ {
		m := it.Method(i)
		g.p("")
		g.GenerateMockMethod(mockType, m)
		g.p("")
		g.GenerateMockRecorderMethod(mockType, m)
	}
}

func typeString(t reflect.Type) string {
	// TODO(jacobsa): Is this correct?
	return t.String()
}

// Represents a flattened list of parameters (either arguments or return values).
type parameterList struct {
	name, t []string // name and type of each arg (name may be empty)
}

// A string suitable for use as a method argument.
func (p *parameterList) argumentString() string {
	strs := make([]string, len(p.t))
	for i, t := range p.t {
		// XXX: doesn't handle anonymous params.
		strs[i] = fmt.Sprintf("%v %v", p.name[i], t)
	}
	return strings.Join(strs, ", ")
}

func buildParameterList(ft reflect.Type) *parameterList {
	n := ft.NumIn()
	params := &parameterList{
		name: make([]string, n),
		t:    make([]string, n),
	}

	for i := 0; i < n; i++ {
		params.name[i] = fmt.Sprintf("param%d", i)
		params.t[i] = typeString(ft.In(i))
	}

	return params
}

func buildReturnList(ft reflect.Type) *parameterList {
	n := ft.NumOut()
	params := &parameterList{
		name: make([]string, n),
		t:    make([]string, n),
	}

	for i := 0; i < n; i++ {
		params.t[i] = typeString(ft.Out(i))
	}

	return params
}

func (g *generator) GenerateMockMethod(mockType string, m reflect.Method) error {
	args := buildParameterList(m.Type)
	rets := buildReturnList(m.Type)

	retString := strings.Join(rets.t, ", ")
	if len(rets.t) > 1 {
		retString = "(" + retString + ")"
	}
	if retString != "" {
		retString = " " + retString
	}

	g.p("func (_m *%v) %v(%v)%v {", mockType, m.Name, args.argumentString(), retString)
	g.in()

	callArgs := strings.Join(args.name, ", ")
	if callArgs != "" {
		callArgs = ", " + callArgs
	}
	if len(rets.t) == 0 {
		g.p(`_m.ctrl.Call(_m, "%v"%v)`, m.Name, callArgs)
	} else {
		g.p(`ret := _m.ctrl.Call(_m, "%v"%v)`, m.Name, callArgs)

		// Go does not allow "naked" type assertions on nil values, so we use the two-value form here.
		// The value of that is either (x.(T), true) or (Z, false), where Z is the zero value for T.
		// Happily, this coincides with the semantics we want here.
		for i, t := range rets.t {
			g.p("ret%d, _ := ret[%d].(%s)", i, i, t)
		}

		retAsserts := make([]string, len(rets.t))
		for i, _ := range rets.t {
			retAsserts[i] = fmt.Sprintf("ret%d", i)
		}
		g.p("return " + strings.Join(retAsserts, ", "))
	}

	g.out()
	g.p("}")
	return nil
}

func (g *generator) GenerateMockRecorderMethod(mockType string, m reflect.Method) error {
	nargs, variadic := m.Type.NumIn(), m.Type.IsVariadic()
	if variadic {
		nargs--
	}
	args := make([]string, nargs)
	for i := 0; i < nargs; i++ {
		args[i] = "arg" + strconv.Itoa(i)
	}
	argString := strings.Join(args, ", ")
	if nargs > 0 {
		argString += " interface{}"
	}
	if variadic {
		if nargs > 0 {
			argString += ", "
		}
		argString += fmt.Sprintf("arg%d ...interface{}", nargs)
	}

	g.p("func (_mr *_%vRecorder) %v(%v) *gomock.Call {", mockType, m.Name, argString)
	g.in()

	callArgs := strings.Join(args, ", ")
	if nargs > 0 {
		callArgs = ", " + callArgs
	}
	if variadic {
		callArgs += fmt.Sprintf(", arg%d", nargs)
	}
	g.p(`return _mr.mock.ctrl.RecordCall(_mr.mock, "%v"%v)`, m.Name, callArgs)

	g.out()
	g.p("}")
	return nil
}

// GenerateMockSource creates source code suitable for saving to a .go file
// that contains mocks for the supplied interface types. The source code uses
// the package name supplied.
func GenerateMockSource(pkg string, interfaceTypes []reflect.Type) (string, error) {
	buf := new(bytes.Buffer)
	g := generator{
		w: buf,
		imports: make(map[string]string),
	}

	g.ScanImports(interfaceTypes)
	err := g.Generate(pkg, interfaceTypes)
	return buf.String(), err
}
